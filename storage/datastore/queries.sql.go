// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package datastore

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :exec
INSERT INTO Person(id, handle, created_at, password, salt)
       VALUES (?, ?, ?, ?,?)
`

type CreateUserParams struct {
	ID        string
	Handle    string
	CreatedAt string
	Password  []byte
	Salt      []byte
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Handle,
		arg.CreatedAt,
		arg.Password,
		arg.Salt,
	)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE from RegistrationToken WHERE expires >= ?
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context, expires string) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredTokens, expires)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM RegistrationToken WHERE pid = ?
`

func (q *Queries) DeleteToken(ctx context.Context, pid string) error {
	_, err := q.db.ExecContext(ctx, deleteToken, pid)
	return err
}

const getPerson = `-- name: GetPerson :one
SELECT  id, handle, password, salt, created_at, display_name, email FROM Person WHERE id = ? LIMIT 1
`

func (q *Queries) GetPerson(ctx context.Context, id string) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Password,
		&i.Salt,
		&i.CreatedAt,
		&i.DisplayName,
		&i.Email,
	)
	return i, err
}

const getPersonByEmail = `-- name: GetPersonByEmail :one
SELECT id, handle, password, salt, created_at, display_name, email FROM Person WHERE email = ? LIMIT 1
`

func (q *Queries) GetPersonByEmail(ctx context.Context, email sql.NullString) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPersonByEmail, email)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Password,
		&i.Salt,
		&i.CreatedAt,
		&i.DisplayName,
		&i.Email,
	)
	return i, err
}

const getPersonByHandle = `-- name: GetPersonByHandle :one
SELECT id, handle, password, salt, created_at, display_name, email FROM Person WHERE handle = ? LIMIT 1
`

func (q *Queries) GetPersonByHandle(ctx context.Context, handle string) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPersonByHandle, handle)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Password,
		&i.Salt,
		&i.CreatedAt,
		&i.DisplayName,
		&i.Email,
	)
	return i, err
}

const getToken = `-- name: GetToken :one
SELECT pid, email, token, expires, refresh FROM RegistrationToken WHERE pid = ? AND expires > ?
`

type GetTokenParams struct {
	Pid     string
	Expires string
}

func (q *Queries) GetToken(ctx context.Context, arg GetTokenParams) (RegistrationToken, error) {
	row := q.db.QueryRowContext(ctx, getToken, arg.Pid, arg.Expires)
	var i RegistrationToken
	err := row.Scan(
		&i.Pid,
		&i.Email,
		&i.Token,
		&i.Expires,
		&i.Refresh,
	)
	return i, err
}

const isEmailRegistered = `-- name: IsEmailRegistered :one
SELECT 1 = 1 FROM Person WHERE email = ? LIMIT 1
`

func (q *Queries) IsEmailRegistered(ctx context.Context, email sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, isEmailRegistered, email)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isRegistered = `-- name: IsRegistered :one
SELECT 1 = 1 FROM Person WHERE handle = ? LIMIT 1
`

func (q *Queries) IsRegistered(ctx context.Context, handle string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isRegistered, handle)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isVerified = `-- name: IsVerified :one
SELECT 1 = 1 from Person WHERE handle = ? AND email IS NOT NULL
`

func (q *Queries) IsVerified(ctx context.Context, handle string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isVerified, handle)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const setPersonEmail = `-- name: SetPersonEmail :one
UPDATE Person SET email = ? WHERE id = ? RETURNING id, handle, password, salt, created_at, display_name, email
`

type SetPersonEmailParams struct {
	Email sql.NullString
	ID    string
}

func (q *Queries) SetPersonEmail(ctx context.Context, arg SetPersonEmailParams) (Person, error) {
	row := q.db.QueryRowContext(ctx, setPersonEmail, arg.Email, arg.ID)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Password,
		&i.Salt,
		&i.CreatedAt,
		&i.DisplayName,
		&i.Email,
	)
	return i, err
}

const setRegistrationToken = `-- name: SetRegistrationToken :exec
INSERT INTO RegistrationToken (pid, email, token, expires, refresh)
       VALUES (?, ?, ?, ?, ?)
ON CONFLICT DO UPDATE SET
    email = excluded.email,
    token = excluded.token,
    expires = excluded.expires,
    refresh = excluded.refresh
`

type SetRegistrationTokenParams struct {
	Pid     string
	Email   string
	Token   string
	Expires string
	Refresh string
}

func (q *Queries) SetRegistrationToken(ctx context.Context, arg SetRegistrationTokenParams) error {
	_, err := q.db.ExecContext(ctx, setRegistrationToken,
		arg.Pid,
		arg.Email,
		arg.Token,
		arg.Expires,
		arg.Refresh,
	)
	return err
}
